import { AppBar, Box, Button, Container, createTheme, CssBaseline, FormControl, Grid, InputLabel, MenuItem, Select, SelectChangeEvent, Stack, TextField, ThemeProvider, Toolbar, Typography } from '@mui/material'
import { url } from 'inspector'
import type { NextPage } from 'next'
import Head from 'next/head'
import { ChangeEvent, useState } from 'react'
import { PuzzleLimit } from '../models/models'
import { calculatePuzzle } from '../services/puzzleCalculator'
import { clearBoard, drawPuzzleBoard } from '../services/puzzlePainter'
import { createPuzzleBoard, getAllPuzzles, PuzzleData } from '../services/puzzleService'

const theme = createTheme();

export interface IHomeProps {
  puzzleData: PuzzleData[];
}

const defaultLimit = {
  limits: {
    atk: undefined,
    hp: undefined,
    eva: undefined,
    acc: undefined,
    def: undefined,
    res: undefined,
    crit: undefined
  },
  order: ["atk", "hp", "eva", "acc", "def", "res", "crit"]
}

const Home: NextPage<IHomeProps> = (props: IHomeProps) => {
  const [puzzle, setPuzzle] = useState<string>("");
  const [puzzleLimit, setPuzzleLimit] = useState<PuzzleLimit>(defaultLimit);

  const calculate = () => {
    var canvas = document.getElementById('mycanvas') as HTMLCanvasElement;

    // Make sure we don't execute when canvas isn't supported
    if (canvas.getContext) {

      // use getContext to use the canvas for drawing
      var ctx = canvas.getContext('2d') as CanvasRenderingContext2D;
      const puzzleData = props.puzzleData.find(x => x.name == puzzle)

      if (puzzleData) {
        clearBoard(ctx);
        const newBoard = createPuzzleBoard(puzzleData);

        const currentCoordinates = newBoard.boardDatas[0][0].coordinates;
        const updatedBoard = calculatePuzzle(currentCoordinates, newBoard, puzzleLimit)
        drawPuzzleBoard(updatedBoard, ctx);
      }
    } else {
      alert('You need Safari or Firefox 1.5+ to see this demo.');
    }
  }

  const reset = () => {
    setPuzzle("");
    setPuzzleLimit(defaultLimit);
  }

  const handleChange = (event: SelectChangeEvent<string>) => {
    setPuzzle(event.target.value);

    var canvas = document.getElementById('mycanvas') as HTMLCanvasElement;

    // Make sure we don't execute when canvas isn't supported
    if (canvas.getContext) {

      // use getContext to use the canvas for drawing
      var ctx = canvas.getContext('2d') as CanvasRenderingContext2D;
      const puzzleData = props.puzzleData.find(x => x.name == event.target.value)

      if (puzzleData) {
        clearBoard(ctx);
        const newBoard = createPuzzleBoard(puzzleData);
        drawPuzzleBoard(newBoard, ctx);
      }
    } else {
      alert('You need Safari or Firefox 1.5+ to see this demo.');
    }
  }

  const handleCounterChange = (event: ChangeEvent<HTMLInputElement>) => {
    const label = event.target.id;
    const newPuzzleLimit = { ...puzzleLimit, limits: { ...puzzleLimit.limits, [label]: parseInt(event.target.value) } }
    setPuzzleLimit(newPuzzleLimit);
  }

  const handleOrderChange = (event: ChangeEvent<HTMLInputElement>) => {
    const label = event.target.id;
    const currentIndex = puzzleLimit.order.indexOf(label);
    const newIndex = parseInt(event.target.value);

    const order = [...puzzleLimit.order];
    order.splice(currentIndex, 1);
    order.splice(newIndex, 0, label);

    const newPuzzleLimit = { ...puzzleLimit, limits: { ...puzzleLimit.limits}, order: [...order] }
    setPuzzleLimit(newPuzzleLimit);
  }

  const limitKeys = Object.keys(puzzleLimit.limits);

  return (
    <ThemeProvider theme={theme}>
      <Head>
        <title>Ni no Kuni: Cross Worlds Puzzle Solver</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <CssBaseline />
      <AppBar position="fixed">
        <Toolbar>
          <Typography variant="h6" color="inherit" noWrap>
            Ni no Kuni: Cross Worlds Puzzle Solver
          </Typography>
        </Toolbar>
      </AppBar>

      <main>
        <Box sx={{ bgcolor: 'background.paper', pt: 8, pb: 6, }}>
          <Container maxWidth="md" style={{ display: 'flex', flexDirection: 'column', flexGrow: 0 }}>
            <Typography variant="h4" align="center" paragraph>
              Choose a puzzle and press calculate button
            </Typography>
            <Stack sx={{ pt: 4 }} direction="row" spacing={2} justifyContent="center">
              <FormControl sx={{ m: 1, minWidth: 120 }}>
                <InputLabel id="puzzleSelect">Puzzle</InputLabel>
                <Select size="small" labelId="puzzleSelect" id="puzzleSelect" value={puzzle} label="Puzzle" onChange={handleChange}>
                  {props.puzzleData.map(p => {
                    return (<MenuItem key={p.name} value={p.name}>{p.name}</MenuItem>)
                  })}
                </Select>
              </FormControl>

              <Button size="small" onClick={calculate} variant="contained">Calculate</Button>
              <Button size="small" onClick={reset} color="secondary" variant='outlined'>Reset</Button>
            </Stack>

            <Grid alignItems="center" style={{ display: 'flex', margin: '0 auto', flexDirection: 'column' }}>

              <Grid item md={12}>
                <canvas id="mycanvas" width="450" height="450" style={{ border: '1px solid black', marginBottom: 5, marginTop: 10 }}></canvas>
              </Grid>

              <Grid md={12} item style={{ display: 'flex', paddingTop: 20 }} alignContent='center'>
                {
                  limitKeys.map(limit => {
                    return (
                      <Grid item md={1} key={limit.toUpperCase()}>
                        <img src={`${limit}.svg`} width="70"></img>
                        <TextField id={limit} label={limit.toUpperCase()} type="number" onChange={handleCounterChange} size="small"
                          inputProps={{ inputMode: 'numeric', min: 0 }} InputLabelProps={{ shrink: true }} value={puzzleLimit.limits[limit]} />

                        <TextField id={limit} label="Order" type="number" onChange={handleOrderChange} size="small" sx={{mt: 3}}
                          inputProps={{ inputMode: 'numeric', min: 0, max: 6 }} InputLabelProps={{ shrink: true }} value={puzzleLimit.order.indexOf(limit)} />
                      </Grid>
                    )
                  })
                }
              </Grid>

            </Grid>

          </Container>
        </Box>

      </main>
    </ThemeProvider>
  )
}

export async function getStaticProps() {
  const puzzleData = await getAllPuzzles();

  return { props: { puzzleData } };
}

export default Home
